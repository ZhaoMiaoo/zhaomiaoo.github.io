---
layout: post
title: Java中的面向对象(上)
category: Java
tags: [JavaSE]
---

java是面向对象的程序设计语言，java语言提供了定义==类==、==成员变量==、==方法==、==构造器==等基本功能。java也支持面向对象的三大特征：==封装==、==继承==和==多态==。

## 1. 类和对象

类和对象是面向对象中的基本内容，其中类是某一批对象的抽象，而对象才是一种具体存在的实体，比如人类是一种抽象的类，而具体到某个人则是人类的实例。可以把类当成是一种自定义类型，使用类来定义对象。

### 1.1 定义类

```java
[修饰符] class 类名 {
    //成员变量b
    //方法
    //构造器
}
```
- 修饰符	public、final/abstract
- Java语法要求类名只要是标识符即可；从专业角度来看，类名需要是有意义的，多个单词构成，每个单词的首字母大写。

### 1.2 定义成员变量

```java
[修饰符] 类型 变量名 [=初始值];
```

- 修饰符	 private/protected/pulic、final、static

> 1. 驼峰写法：首单词小写，后面的每个单词首字母大写
> 2. 常量：常量是再定义并附赋值后永远不会改变的特殊变量，单词之间用下划线隔开，全部大写

### 1.3 定义方法

```java
[修饰符] 返回值类型 方法名(形参列表) {
	//方法体
}
```

- 修饰符	private/protected/pulic、final、abstract、static、void 
- 返回值类型：如果声明了返回值类型，则方法体中必须要有return语句；若返回值类型声明为void，则不需要return语句。 
- 方法名--驼峰写法 
- 形参列表：  ( 形参类型 形参名1，形参类型 形参名2，形参类型 形参名3…… ) 

### 1.4 定义构造器

构造器最大的用处就是在创建对象时执行初始化。如果类没有自定义构造器，系统会为这个对象的实例进行默认的初始化（无参的）。

> 构造器名必须要与类名相同，且构造器中没有return语句。

### 1.5对象的创建和使用

####  对象的创建和初始化

```java
类名 变量名 = new 类的构造器();
```

> 类是一个引用类型，引用类型变量的赋值只是将对象的首地址存入变量中。对象存在堆内存中，变量存在栈内存中

#### 对象的使用

1. 访问对象的实例变量 

   对象名.变量名

2. 调用对象的实例方法

   对象名.方法名

> 关于static修饰符
>
> 1. 被static修饰的方法和变量是属于类的，应该通过类来访问和调用
> 2. 没有被static修饰的方法和变量是属于对象的，只能通过对象访问和调用

#### 对象的this引用

- 如果this出现在非static方法中，则this指向调用该方法的对象

- 如果this出现在static方法中，则this指向该方法的类

  > 类是无法访问没有static修饰的实例方法的，如果在static方法中使用this，this会指向类，这个时候编译会报错。如果要在static方法中使用非static方法，必需要创建对象后调用。

- 如果this出现在构造器中，则this指向正在初始化的对象





## 2. 方法详解

### 2.1 方法的所属性

从方法的定义和方法的功能来看，方法和函数非常像。在面向过程的程序设计中，程序由一个个的函数组成；但是在面向对象的程序设计中，程序由一个个的类组成，因此在java中方法是不能独立存在的。

1. 方法类似于函数，但是不能独立存在，必须定义在类中

2. 方法不能独立运行，一定要有调用者

   > 如果调用统同类中的方法，可以省略调用者，但是调用者实际上也是存在的，java编译时会自动添加默认的调用者。

### 2.2 方法参数的传递

java中参数的传递与c语言相同，只是将实参的值传递给形参，而在方法中形参值的改变与实参本身的值无关。

> 如果方法参数是引用变量，与基本类型不同，引用变量中是对象的首地址，当方法中对形参指向的实例成员变量进行修改赋值时，会影响实参。

### 2.3 形参个数可变的方法

```java
public void arc(int... i)
```

其实本质就是数组，调用方法的时候有两种使用方法：

```java
Test.arc(3, 5, 7, 9);
Test.arc(new int[]{3, 5, 7, 9});
//以上两种调用的方法效果完全一样
```

如果直接把参数写成数组

```java
public void arc(int[] i)
Test.arc(new int[]{3, 5, 7, 9})
//只能使用这一种调用的方法
```

很显然使用形参可变的方法，在调用方法时更加方便，直接传入多个元素，由系统封装成数组。==但要注意这种写法只能作为形参列表的最后一个形参==

### 2.4 方法重载

java中允许在同一个类中定义多个同名的方法，只要形参列表不同就行。

```java
public void Test(int i, String str){}
public int Test(double d) {
    return 0;
}
//调用Test方法的时候，系统会根据传入的参数执行不同的方法
```





## 3. 变量详解

java中的变量按结构分为：

![image-20180814214409889](https://ws2.sinaimg.cn/large/0069RVTdgy1fu9kc2uqmbj30om0fa76k.jpg)



- 成员变量：是在类中定义的变量，其中被static修饰是类变量，非static变量是实例变量。
- 局部变量：是在方法中定义的变量，其中定义方法时的定义的形参，代码块中定义的变量，其余局部变量是普通变量。

> 成员变量在定义的时候可以不指定初始值；局部变量在定义的时候必须指定初始值，否则编译会报错。

> 通过对象访问类变量的时候，java会将对象换成所属的类，通过对象访问类变量是假象 。





## 4. 构造器详解

构造器是一个特殊的方法，这个特殊的方法用于在创建对象时执行初始化

### 4.1 使用构造器进行执行初始化

#### 定义构造器：

```java
public void Test(int i, String str){
    this.i = i;
    this.str = str;
    System.out.println("对象完成初始化");
}
```

#### 初始化:

```java
Test obj = new Test(50,"Hello");
```

### 4.2 构造器重载

同一个类中有多个构造器，各个构造器的形参列表不同，成为构造器重造。java允许一个类中有多个初始化逻辑，从而以不同的构造器来初始化对象。通过new调用构造器时，系统将根据传入参数的不同执行不同的构造器。

### 4.3 构造器中的this调用

在构造器重载中可能出现构造器A调用构造器B的情况，但是构造器不能被直接调用，如果使用new关键字来调用构造器，会使系统重新创建对象。为了在构造器A中调用构造器B，又不会重新创建对象造成资源浪费，可以使用this关键字对用对应的构造器。

```java
this(实参列表);
```

> this调用只能出现在构造器的开头 





## 5. 封装

封装是面向对象的三大特征之一，他指的是将对象的状态信息隐藏在对象内部，通过类提供的方法来实现对内部信息的操作和访问。

#### 封装的目的：

○ 隐藏类的实现细节

○ 限制使用者对成员变量的不合理访问

○ 便于修改，提高代码的可维护性

#### 控制符

java中封装需要通过访问控制符来实现：

**private**---------当前类访问权限
			 只能在类中被访问

**default**---------不写修饰符，包访问权限
			 能在类及所在包中被访问

**protected**------子类访问权限
			 能在类、所在包及类的子类中被访问
**public**---------- 公共
		  	 能在任意地方被访问

#### 封装的手段：

1. 用private修饰主要的成员变量，只有少数类似全局变量的static的变量才考虑使用public修饰

2. 为成员变量定义对应public的getter、setter方法，实现外界对内部变量的安全访问


## 6. 包

由于不同的开发者很容易定义相同名称的类，java中引入包机制。 

### 6.1 package（定义包） 

```java
package com.baidu.javase;
```

为类指定包之后，非包内的类使用该类需要完整类名，包名.+类名

> 包名：为了不同公司的包名发生重复，Oracle规定以域名倒写加项目名的格式来作为包名

### 6.2 import（导入指定包的类）

```java
//只导入一个类
import com.baidu.javase.Tset;
//导入整个包的类
import com.baidu.javase.*;
```

导入后可以可以省略写包名

### 6.3 import static（静态导入）

```java
//只导入类中的一个静态成员
import static com.baidu.javase.Tset.eat;
//导入整个包的所有类
import static com.baidu.javase.Test;
```

导入后，可以省略写包名、类名








## 7. 继承

继承是面向对象的三大特征之一，继承是一种类与类的关系，子类是一种特殊的父类，子类实例完全可以当做父类实例来使用。子类继承父类后，子类得到父类的全部成员变量、方法。以此实现代码的复用。

```java
public class B extends A{
    //类B继承了类A，得到类A的成员变量和方法
}
```

### 7.1 方法重写

父类的方法不适用子类情况下，要对父类继承的方法进行重写，有如下规则：

- 方法名、形参列表相同
- 返回值类型、声明抛出的异常相同或更小
- 访问权限相同或更大
- 重写的方法前加上@override，如果没有覆盖的方法，编译器会报错

> 区别于方法重载(overload)，方法重载是发生在同一类下的同名类，而方法重写是发生在子类重写父类方法，二者完全没有关系

### 7.2 super关键字

super与this非常相似，super用法如下 

1. super限定

   在子类中限定访问父类的成员变量和方法，语法与this引用一样

2. super调用

   在子类的构造器中调用父类的构造器

   `super(参数1,参数2)；`

   > 如果子类构造器中没有调用父类构造器，java会默认调用父类的无参数构造器。如果父类没有无参数构造器，则在子类构造器中的第一行必须显示调用父类构造器。





## 8. 多态

多态是面向对象的三大特征之一。多态是指同一个类型的多个实例，执行同一个方法，表现出不同的行为。在java中引用变量编译时的类型和运行时的类型不同，在调用对象方法的时候就可能会出现多态的情况。 

### 8.1上转型（自动转换）

java中允许把子类对象赋值给父类类型的引用变量，在编译的时候变量是父类类型，而实际运行时，是子类的类型。如果子类对父类的成员变量和方法有重写，这个时候多态就发生了。 

#### 上转型的规律

1. 成员变量：

   不论子类中是否对成员变量重写，实际访问的是父类的成员变量。

2. 方法：

   如果子类对方法重写，实际执行的是子类重写后的方法 ；若没有重写，则执行的是父类的方法

   > 如果调用的方法父类中没有，编译会报错，因为编译类型是父类（如果要调用子类中父类没有的方法，需要强制转换）

### 8.2 下转型

下转型是把父类对象赋值给子类类型的引用变量 。在java中引用变量只能调用编译时类型的方法，而不能调用运行类型的方法。在进行上转型后，不能调用子类中的方法。如果要让这个引用变量调用运行时的方法，需要把他强制转换为运行时类型。

> 此时不是真的将父类对象的首地址存入子类变量，父类变量实际上指向的是子类对象，下转型本质上是父类引用类型转换为子类引用类型，转换的是编译时变量类型，而运行时的类型是不会改变的。

```java
Object a = new C1();
c1 b = (C1)a;
//此时编译类型和运行类型一样，可以调用子类C1中的方法
```

#### 强制转换的注意事项

- 强制转换的类型之间必须有继承关系，才能通过编译
- 强制转换的类型和运行类型不一样，编译能通过，但是在运行时会出现类型转换异常的报错。==也就是说只能将引用变量的类型从编译时类型强制转换为运行时类型！！==

### 8.3 instanceof

为了避免类型转换异常，java中有instanceof这个运算符。

`变量名 instanceof 类型`

当变量所引用的对象是后面类或者子类的实例是，返回ture，否则false。

> 这个运算符只能判断有继承关系的，否则会编译报错。







## 9. 初始化块

初始化块是java类可出现的第四种成员。初始化块在类中以`{//各种代码}`的的形式出现。和构造器非常类似，初始快也可以对java对象进行初始化操作。

#### 实例初始化块

实例初始化块是没有static修饰的初始化块

> **实例初始化块的“假象”**
>
> - 一个类在编译之后，实例初始化块会消失。消失的代码会被还原到该类中每个构造器的所有代码前面。
> - 非static变量定义后赋初始值实际上也是一种假象。赋值这个语句会消失，同实例初始化块一样被还原到所有代码前面。
> - 多个赋值语句和多个实例初始化块都会被还原到构造器的开头，他们的顺序同在源代码中排列的顺序。

当多个构造器前面有相同的代码时，可以提取到初始化块中，实现代码的复用，有方便了日后修改。

#### 类初始化块

负责对类执行初始化。当程序第一次==主动==使用该类是，系统会对该类分配内存空间、并执行初始化块。
> 除了用类声明变量之外，所有使用类都算是“主动”。


> - 在一次程序运行周期中，类初始化块只能执行一次。而每次初始化对象的时候实例初始化块都会被执行
> - 在程序第一次初始化某类的对象时，类初始化块和实例初始化块都会执行，类初始化块先于实例初始化块。
> - 子类的各种初始化（初始化块和构造器）会依次执行祖先类的初始化，最后才执行自己的初始化







## 10. 组合

继承是实现代码复用的重要手段，但是继承带来了一个最大的坏处：破坏封装。在继承关系中，子类可以直接访问复位的成员变量和方法，从这个角度来看，父类的实现细节对子类不再透明，并且可以改变父类的实现细节（方法重写）。

通过组合也可以实现代码的复用，提供刚好的封装性。

组合就就是在类中创建一个其他类的对象，可以在类中安全的使用他的方法、变量，并添加一些新的特性。